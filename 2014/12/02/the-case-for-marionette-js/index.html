<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><script type="text/javascript" src="//use.typekit.net/msd6bqv.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script><title data-react-helmet="true">The Case For Marionette.js | benmccormick.org</title><style>.header-link{color:hsla(0,0%,39%,.7)}.header-link:hover{color:#e2777a}.markdown pre{display:block;background:#fdf6e3;color:#657b83;overflow-y:hidden;padding:.2rem .5rem}.markdown pre code{background:none;border:none;border-radius:3px;display:inline-block;overflow:inherit;padding:0;white-space:inherit;word-wrap:normal;font-size:.7rem;line-height:1rem}code{border-radius:3px;white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;border:1px solid #ccc;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:0 .1625rem}.hljs,code{background:#fdf6e3;color:#657b83}.hljs{display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#93a1a1}.hljs-addition,.hljs-keyword,.hljs-selector-tag{color:#859900}.hljs-doctag,.hljs-literal,.hljs-meta .hljs-meta-string,.hljs-number,.hljs-regexp,.hljs-string{color:#2aa198}.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-title{color:#268bd2}.hljs-attr,.hljs-attribute,.hljs-class .hljs-title,.hljs-template-variable,.hljs-type,.hljs-variable{color:#b58900}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-meta .hljs-keyword,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-subst,.hljs-symbol{color:#cb4b16}.hljs-built_in,.hljs-deletion{color:#dc322f}.hljs-formula{background:#eee8d5}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}body,h1,h2,h3,h4,h5,h6,p{font-family:brandon-grotesque,Brandon Grotesque,Helvetica Neue,Helvetica,Arial,Lucida Sans,Geneva,Verdana,sans-serif;text-rendering:optimizeLegibility}a{color:#e2777a;text-decoration:none}blockquote{border-left:5px solid #57a3e8;font-style:italic;background:#eee;font-weight:400;font-size:.9rem;padding:10px 20px;margin:0 0 30px -25px}h2,h3{color:#57a3e8}.explanation{padding:10px;background:#eee;border-radius:10px;margin:20px auto;font-size:.85em}.reading-img img{width:150px;float:right;margin:10px}</style></head><body class="landing-page" style="background:#FCFCFC;"><div id="react-mount"><div style="max-width:39.984rem;margin-left:auto;margin-right:auto;padding:2.499rem 1.2495rem;" data-reactroot="" data-reactid="1" data-react-checksum="-1468373986"><div style="display:flex;padding-bottom:0.5rem;margin-bottom:0.5rem;" data-reactid="2"><div style="flex-grow:3;display:flex;flex-direction:column;justify-content:space-around;" data-reactid="3"><h3 style="margin:0;padding-bottom:0;" data-reactid="4"><a style="box-shadow:none;text-decoration:none;color:inherit;" href="/benmccormickorg/" data-reactid="5">benmccormick.org</a></h3><div style="color:rgba(100,100,100, 0.7);" data-reactid="6"><a class="header-link" href="/benmccormickorg/subscribe/" data-reactid="7">Subscribe</a><span style="padding:0 0.33rem;" data-reactid="8">•</span><a class="header-link" href="/benmccormickorg/readinglist/" data-reactid="9">Reading List</a><span style="padding:0 0.33rem;" data-reactid="10">•</span><a class="header-link" href="http://twitter.com/ben336" data-reactid="11">Twitter</a><span style="padding:0 0.33rem;" data-reactid="12">•</span><a class="header-link" href="/benmccormickorg/about/" data-reactid="13">About</a></div></div><div style="flex-shrink:2;" data-reactid="14"><div data-reactid="15"><div style="max-height:6.5rem;display:flex;justify-content:flex-end;background:#F0F0F0;padding:0.2rem;" data-reactid="16"><div data-reactid="17"><a href="https://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182/ref=as_li_ss_il?ie=UTF8&amp;linkCode=li1&amp;tag=benmccormicko-20&amp;linkId=204d9fef609d10bc79cb424fc44fd1ab" target="_blank" data-reactid="18"><img src="//ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=0321812182&amp;Format=_SL110_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=benmccormicko-20" data-reactid="19"/><img src="https://ir-na.amazon-adsystem.com/e/ir?t=benmccormicko-20&amp;l=li1&amp;o=1&amp;a=0321812182" width="1" height="1" alt="" style="border:none;margin:0px;" data-reactid="20"/></a></div><div style="font-size:0.6em;line-height:1em;max-width:5rem;padding:0 0.5rem;display:flex;align-items:center;flex-direction:column;justify-content:space-between;color:rgba(100, 100, 100, 0.701961);" data-reactid="21"><span data-reactid="22">Please support this blog by shopping on Amazon</span><a href="/benmccormickorg/amazonlinks" data-reactid="23">What is this?</a></div></div></div></div></div><div class="markdown" data-reactid="24"><!-- react-empty: 25 --><h5 style="display:block;color:rgba(100,100,100, 0.7);margin-bottom:0.4165rem;" data-reactid="26">December 1, 2014</h5><h1 style="margin-top:0;margin-bottom:1rem;" data-reactid="27">The Case For Marionette.js</h1><div class="article-body" data-reactid="28"><p>Building large web applications using <a href="http://backbonejs.org/">Backbone.js</a> can be hard.  Backbone is a great tool, but it’s designed to be minimalist and useful in a wide variety of situations.  As a result, you get less guidance and support from the tool as you scale up than you do from more opinionated frameworks like <a href="https://angularjs.org/">Angular</a> and <a href="http://emberjs.com/">Ember</a>.  When a Backbone application grows, maintaining it requires adding structure, either through a custom set of conventions and components, or based on somebody elses framework.  There are a lot of different Backbone frameworks out there, but I want to make the case for using <a href="http://marionettejs.com/">Marionette.js</a>.</p>
<p><img src="/content/images/2014/12/marionettelogo.png" alt="Marionette Logo"></p>
<p>I’ve been using Marionette for the past year, and it’s been incredibly valuable.  It’s really helped ease a lot of the initial issues I found with scaling out Backbone.  But there was one big issue with Marionette when I started with it. It was not simple to figure out how exactly I should be using it.</p>
<p>When I start to use a new piece of software, I’m always hoping to see 2 types of documentation.  The first is the nitty-gritty stuff that most people associate with documentation.  What are the APIs available, what can you pass to them, what components, features, or functions does it provide?  The second type is what I think of as the “story telling” documentation.  It overlaps a bit with marketing, but basically it’s the documentation that explains the value of the software, gives you ideas on how you might use it, and outlines the philosophy that lead to the tool.  Without the first type of documentation you end up with an exciting idea that you may struggle to implement.  Without the second type, you can end up with a lot of nice tools that you aren’t sure how to combine together.</p>
<p>Marionette is great, but it’s a tool that doesn’t have much of the story telling documentation I mentioned above.  It gets off to a good start, with the following intro on its website:</p>
<blockquote>
<p>Backbone.Marionette is a composite application library for Backbone.js that aims to simplify the construction of large scale JavaScript applications.</p>
</blockquote>
<blockquote>
<p>It is a Collection of common design and implementation patterns found in the applications that we have been building with Backbone, and includes pieces inspired by composite application architectures, event-driven architectures, messaging architectures, and more.</p>
</blockquote>
<p>But the site fails to follow through on explaining the values or philosophy that went into building it.  Instead, when you start with Marionette you’re left with a bunch of components that are well documented individually, without much guidance on how to put them together or use them.  Any explanation of the value added is scoped to an individual component in the docs, and there’s no real indication of why these particular components are bundled together. I’m going to try and provide this type of high level explanation of the value that Marionette can bring, laying out the big picture in this piece and then digging into each area of value in future posts.  To start, let’s look at the problems that Marionette is trying to solve.</p>
<h3>Decisions, Decisions</h3>
<p>Developing with Backbone is an exercise in decision making.  Backbone provides you with a minimalist set of Models and Collections that essentially serve as light wrappers around JavaScript objects synced over Ajax. It provides you lightweight Views that associate an object with a DOM node and some data.  It provides a router that associates URLs with function, and it provides helpers for managing events between all of these options.  That leaves Backbone developers with many questions to answer.</p>
<ul>
<li><strong>How do you render Views?</strong> - By default, Backbone’s render method does nothing. To use it, you need to fill in your own rendering function.  That could use a templating system like Underscore templates or Handlebars, jQuery manipulation of the DOM, or simple string inserts with <code>.innerHTML()</code>.  You could use the same method for every View, or mix it up and use different methods for different Views.</li>
<li><strong>How do you manage relationships between objects?</strong> - By default Backbone provides a way to manage sets of Models as a Collection, but it doesn’t have any built-in utilities for handling nested Models or Collections.  And if you want to nest your Views you’re completely on your own.  You can have a View manage it’s child Views, have a single object that manages all Views, or let each View manage itself.</li>
<li><strong>How do your Views communicate between each other?</strong> - Views will often need to communicate with each other.  If for instance one View needs to change the contents of another area of the page, it could do so directly through jQuery, could get a direct reference to a View managing that area and call a function on it, change a Model that another View listens to, adjust a URL that a router listens to, or fire an event that another View could respond to. Apps can use some combination of all of these methods.</li>
<li><strong>How do you avoid repeating yourself?</strong> - If you’re not careful, Backbone can involve a lot of boilerplate.  Taking the naive approach, you could end up writing rendering code, View management code and event management code over and over again in every View.  If you try to get around that using inheritance, you can end up with brittle designs that require you to make calls down to a Views prototype when you want View specific code.  Avoiding that type of repetition and the maintenance overhead it brings is a challenge.</li>
<li><strong>How do you manage a View’s life-cycle??</strong> - What code is responsible for rendering a View?  Does it render itself on creation?  Or is it the responsibility of the object creating it?  Does it get attached to the DOM immediately on render? Or is that a separate step?  When the View is removed from the DOM or deleted, how do you handle any cleanup that is needed?</li>
<li><strong>How do you structure your application?</strong> - How do you get your app started?  Do you have a central object that starts everything, or is it more distributed?  If you do centralize, do you use the router to start things, or provide some other object for managing your code?</li>
<li><strong>How do you prevent memory leaks?</strong> - If your application is a <a href="http://en.wikipedia.org/wiki/Single-page_application">Single Page Application</a> or it contains long lasting interactive sections, another issue that you may need to deal with is memory leaks.  It can be easy to create “zombie Views” in Backbone if you’re not attentive to the need to unregister events attached to a View after you’re done with it.</li>
</ul>
<p>That’s just a small sample of the type of decision making that you have to make for a Backbone project.  Those questions signify flexibility, but they also represent mental overhead.  If you’re like me, you see these common problems and think that you can get better results relying on a shared solution that leverages the experience of the community.</p>
<h3>What does Marionette Give You?</h3>
<p>Marionette is an attempt to provide this type of shared solution, capturing Backbone best practices as a set of components and design patterns.  So what value does it provide?  Marionette gives you:</p>
<ul>
<li><strong>A Standardized Rendering process</strong> - Marionette takes an opinionated stand on how Views should be rendered.  Without any additional configuration, it will take a template that you specify with a View’s template property, compile it with Underscore’s templating function and pass it a model or collection.  If you need to pass it other data, or want to use a different template library, Marionette provides hooks to customize that process in a <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> way.</li>
<li><strong>A consistent View lifecycle</strong> - Marionette defines a consistent View life cycle where Views are initialized, rendered, shown, refreshed, and destroyed.  Each of these events has events and callbacks associated it, and any common boilerplate associated with them is handled behind the scenes.</li>
<li><strong>The ability to define and manage complex layouts</strong> - Marionette provides region objects that define portions of the DOM that can display and swap out Views.  Combined with utilities to manage child views, you can easily create deeply nested View structures with Marionette while minimizing complexity.</li>
<li><strong>A central event bus with semantic events to simplify communication between Views</strong> - Marionette includes Backbone.Wreqr or Backbone Radio as an event bus to allow communication between Views without explicitly coupling them.</li>
<li><strong>Helpers to help you write DRY Code</strong> - In addition to centralizing the rendering and view management code, Marionette provides hooks to allow you to abstract away details of the DOM and events in your View code, and a mechanism to pull common ui operations out into separate reusable objects</li>
<li><strong>Helpers to avoid “Zombie Views” and memory leaks</strong> - Marionette’s lifecycle includes an explicit destroy phase that cleans up many common sources of memory leaks, and provides a hook for you to take care of the rest</li>
<li><strong>A central Application object to initialize your application</strong> - Using Marionette, you’re able to specify a set of initializers that run any code that needs to be executed before your application starts, providing a clear structure and starting point to your app.</li>
</ul>
<p>That’s not the complete feature set, but it is the essential sales pitch.  I’ll be digging deeper into each of these advantages over my next few posts, but the important thing to understand is that Marionette provides a framework for building Backbone apps that builds on established practices from the community.  If you’re building a Backbone application and want to focus on the problems that are specific to your application, Marionette is a great way to move past common issues and focus on what’s unique to you.</p>
<h3>More Resources</h3>
<ul>
<li>For a practical introduction to Marionette, you could do much worse than <a href="https://www.youtube.com/watch?v=PrQSpdWkN6Q">this talk</a> from the recent Nodevember conference.  Jeremy Fairbank, a member of the Marionette core team, explained how you can use Marionette to improve the architecture of your Backbone apps.</li>
<li>The resource that best helped me understand Marionette isn’t technically about Marionette at all.  Derek Bailey’s book <a href="https://leanpub.com/building-backbone-plugins?a=3a4Srv2pP9p87WQ_eoDoGp">Building Backbone Plugins</a> lays out the philosophy and thinking behind Marionette without directly referencing it, explaining the challenges that he faced in building a useful abstraction over Backbone.  You can read my <a href="http://benmccormick.org/2014/07/09/understanding-the-backbone-mindset-a-review-of-building-backbone-plugins-by-derick-bailey/">full review</a> if you’re interested, but I highly recommend it for any Backbone developer as a way of better understanding how to structure your Backbone applications.</li>
</ul>
<h3>Subscribe</h3>
<p>Thanks for taking the time to read this post! This post was the first in a series on Marionette.js, so if you enjoyed the post, please consider subscribing by using the <a href="http://feedpress.me/benmccormick">feed</a>, <a href="http://twitter.com/benmccormickorg">Twitter</a> or my <a href="http://eepurl.com/WFYon">mailing list</a>. You also might want to check out my <a href="http://benmccormick.org/2014/11/12/underscore-vs-lodash/">recent post</a> on choosing between Underscore and Lo-Dash.</p>
<style>
.post-body img {
display: block;
max-height: 200px;
margin: 30px 5px;
float: right;
}
</style>
</div><hr style="margin-bottom:3.332rem;" data-reactid="29"/><noscript data-reactid="30"></noscript><p style="margin-bottom:4.165rem;" data-reactid="31"><!-- react-text: 32 -->Written by <!-- /react-text --><!-- react-text: 33 -->Ben McCormick<!-- /react-text --></p></div><span style="display:block;clear:both;" data-reactid="34"> </span></div></div><script src="/benmccormickorg/bundle.js?t=1474689456602"></script><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-37323973-1', 'auto');
            ga('send', 'pageview');
        </script></body></html>