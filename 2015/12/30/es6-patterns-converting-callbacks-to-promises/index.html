<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=yyxgnp97qG"/><link rel="icon" type="image/png" href="/favicon-32x32.png?v=yyxgnp97qG" sizes="32x32"/><link rel="icon" type="image/png" href="/favicon-16x16.png?v=yyxgnp97qG" sizes="16x16"/><link rel="manifest" href="/manifest.json"/><link rel="mask-icon" href="/safari-pinned-tab.svg?v=yyxgnp97qG" color="#57a3e8"/><link rel="shortcut icon" href="/favicon.ico?v=yyxgnp97qG"/><meta name="theme-color" content="#ffffff"/><script type="text/javascript" src="//use.typekit.net/msd6bqv.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script><title data-react-helmet="true">ES6 Patterns: Converting Callbacks to Promises | benmccormick.org</title><meta data-react-helmet="true" name="description" content="How to convert a callback driven API to a Promise-based one"/><meta data-react-helmet="true" name="keywords" content=""/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:site" content="@benmccormickorg"/><meta data-react-helmet="true" name="twitter:creator" content="@ben336"/><meta data-react-helmet="true" name="twitter:title" content="ES6 Patterns: Converting Callbacks to Promises"/><meta data-react-helmet="true" name="twitter:description" content="How to convert a callback driven API to a Promise-based one"/><meta data-react-helmet="true" name="twitter:image" content="http://benmccormick.org/logo.png"/><script data-react-helmet="true" type="application/ld+json">{
                "@context": "http://schema.org"
                "@type": "BlogPosting",
                "headline": "ES6 Patterns: Converting Callbacks to Promises",
                "genre": "Software Development",
                "keywords": "",
                "url": "http://benmccormick.org/2015/12/30/es6-patterns-converting-callbacks-to-promises/",
                "image": "http://benmccormick.org/logo.png",
                "datePublished": "2015-12-29",
                "description": "How to convert a callback driven API to a Promise-based one",
                "articleBody": "<div class=\"explanation\">
I've been writing code using the new features defined in the ECMAScript 2015 version of JavaScript (<a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\">more commonly known as ES6</a>) since January.  Throughout the year I've seen myself start using a few new patterns that I think make my code better.  I'm going to share them here with a few quick hitter articles.  If you missed it, I wrote about <a href=\"http://benmccormick.org/2015/11/30/es6-patterns-clean-higher-order-functions/\">clean higher order functions</a> earlier this week.  This post focuses on working with asynchronous code in ES6.  
</div>
<h3>Background</h3>
<p>One of the nicest new features of ES6 JavaScript is the standardization of Promises.  Promises are a method for managing asynchronous code that serve as an alternative to the standard callback function syntax that has been the JavaScript standard for years.  If you’re unfamiliar with them, a good example of a Promise based API is the new <code>fetch</code> api provided by browsers.  <code>fetch</code> is a replacement for the older callback based XMLHttpRequest API.  A quick example of an HTTP request with the 2 APIs provides a nice comparison of how Promises can lead to clearer code.</p>
<p>A simple get request with XMLHttpRequest looks like this:</p>
<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reqListener</span>(<span class=\"hljs-params\"></span>) </span>{  
  <span class=\"hljs-keyword\">var</span> data = <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-keyword\">this</span>.responseText);  
  <span class=\"hljs-built_in\">console</span>.log(data);  
}

<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reqError</span>(<span class=\"hljs-params\">err</span>) </span>{  
  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Fetch Error :-S'</span>, err);  
}

<span class=\"hljs-keyword\">var</span> request = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();  
request.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{
  <span class=\"hljs-keyword\">var</span> data = <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-keyword\">this</span>.responseText);  
  <span class=\"hljs-comment\">//do stuff with data</span>
};  

request.onerror = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{
    alert(<span class=\"hljs-string\">'There was a problem with the request'</span>);
}
request.open(<span class=\"hljs-string\">'get'</span>, <span class=\"hljs-string\">'/api/foo/bar'</span>, <span class=\"hljs-literal\">true</span>);  
request.send();
</code></pre>
<p>whereas with fetch we get this instead</p>
<pre><code>fetch(<span class=\"hljs-string\">'/api/foo/bar'</span>).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span> {</span>
    <span class=\"hljs-keyword\">return</span> data.json();
}).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(jsonData)</span> {</span>
    <span class=\"hljs-comment\">//do stuff with the data</span>
}).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(e)</span> {</span>
    alert(<span class=\"hljs-string\">'There was a problem with the request'</span>);
})
</code></pre>
<p>This is admittedly a slightly unfair example due to XMLHttpRequest’s clunky object oriented API, but the key take away here is that promises allow for easier visualization of a program’s flow, as well as the ability to easily chain both synchronous and asynchronous operations together into a unified API.</p>
<p>Promises have been around for a little while in user-land.  There are a bunch of Promise libraries out there that eventually standardized on a spec called <code>Promises/A+</code>.  Promises/A+ compliant libraries include <a href=\"https://github.com/kriskowal/q\">Q</a>, <a href=\"https://github.com/petkaantonov/bluebird\">Bluebird</a>, and <a href=\"https://github.com/tildeio/rsvp.js\">rsvp</a>.  There are also many older libraries that provide Promise-like capabilities but are not completely spec compatible, most notably <a href=\"https://api.jquery.com/category/deferred-object/\">jQuery deferreds</a>.  But with ES6 Promises are being standardized.  Happily, since the implementation uses the standard that user-land libaries have agreed upon, the Promise spec is compatible with existing implementations, and existing code bases can remove their existing libraries in favor of the browser supplied version, or have code written to use the browser version interop cleanly with their existing code.  Support for Promises now exists in the latest versions of all major browsers, but it never made it to Internet Explorer and is Edge only for Microsoft browsers.  So most developers will still want to consider using a polyfill for the time being.</p>
<h3>Converting callback-driven code to use Promises</h3>
<p>If you believe that Promises are worthwhile, you’ll immediately encounter a problem in today’s JavaScript world.  Many JavaScript APIs, including most standard browser APIs and older but still popular libraries like jQuery and Backbone are heavily callback driven.  Rather than mixing 2 different styles of asynchronous code, wouldn’t it be nice if we could easily convert callback-based APIs to use Promises?  It turns out that it’s not that hard.  Let’s take the simplest example possible to start.  <code>setTimeout</code> is a straightforward browser API that waits for a specified period of time and then executes a callback.  A standard use looks like this:</p>
<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doStuff</span><span class=\"hljs-params\">()</span> </span>{<span class=\"hljs-comment\">/*...*/</span>}

setTimeout(doStuff, <span class=\"hljs-number\">300</span>);
</code></pre>
<p>A Promise-based API for this function would likely look something like this code.</p>
<pre><code><span class=\"hljs-function\"><span class=\"hljs-title\">timeout</span><span class=\"hljs-params\">(<span class=\"hljs-number\">300</span>)</span></span>.then(doStuff)
</code></pre>
<p>We can create an API like that using setTimeout.  To do that, we’ll need a function <code>timeout</code> which takes a timeout variable and returns a Promise.</p>
<p>You can define A+ compliant Promises using the Promise constructor, which expects a single function as an argument.  That function takes 2 arguments, a <code>resolve</code> function and a <code>reject</code> function.  The wonderful thing is that under the covers these are just callback functions that the Promise api glosses over.</p>
<p>Since we already have an API that can handle callbacks, the implementation of our <code>timeout</code> function is pretty simple.</p>
<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">delay</span>) </span>{
    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{
        setTimeout(resolve, delay);
    });
}
</code></pre>
<p>We don’t use the reject callback, since setTimeout doesn’t provide any hooks for an error state. So we pass resolve as the callback to setTimeout, and that is all we need.  Now we have a great chainable setTimeout function that we could include in a Promise chain.</p>
<p>Moving on to a more complicated example, let’s take our <code>XMLHttpRequest</code> code from above and see if we can create a simplified version of the <code>fetch</code> API using <code>XMLHttpRequest</code> under the covers.  In this case I’m going to use ES6 style arrow functions to reduce the boilerplate a bit.</p>
<pre><code><span class=\"hljs-keyword\">const</span> fetch = <span class=\"hljs-function\">(<span class=\"hljs-params\">url, options = {method:<span class=\"hljs-string\">'get'</span>}</span>) =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {
    <span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();  
    request.onload = resolve
    request.onerror = reject;
    request.open(options.method, url, <span class=\"hljs-literal\">true</span>);  
    request.send();
});
</code></pre>
<p>This is a simplified implementation that doesn’t come close to covering all the use cases of fetch, but it provides a great example of how simple it can be to transform a callback based api to a Promise based one, without having to rewrite the existing code<sup id=\"fnref:1\"><a href=\"#fn:1\">1</a></sup>.</p>
<p>For what it’s worth, it is equally easy to convert functions in the other direction.  For instance a callback based implementation of fetch can be a one liner.</p>
<pre><code>const callbackFetch = <span class=\"hljs-function\"><span class=\"hljs-params\">(url, options, succ, err)</span> =&gt;</span> fetch(url, options).<span class=\"hljs-keyword\">then</span>(succ).<span class=\"hljs-keyword\">catch</span>(err);
</code></pre>
<p>It’s useful to know that the various syntaxes for asynchronous code in JavaScript are effectively equivalent and interoperable.  When designing APIs for your code, both for public libraries with external libraries and components that you use in an application, these patterns can be useful for providing a consistent API, even if you’re using code under the covers that presents it’s asynchronous code in a different way than your API.</p>
<h3>More Resources</h3>
<ul>
<li>The free online version of Exploring ES6 by Axel Rauschmayer has a <a href=\"http://exploringjs.com/es6/ch_promises.html\">great chapter</a> on ES6 Promises explaining the API and how they fit in with the A+ standard.</li>
<li>There was also a <a href=\"http://blogs.msdn.com/b/eternalcoding/archive/2015/09/30/javascript-goes-to-asynchronous-city.aspx\">great post by David Catuhe on one of the MSDN blogs</a> earlier this year highlighting how asynchronous code has evolved in JavaScript over the years, including a look at the new <code>async/await</code> patterns proposed for ES2016.</li>
</ul>
<h3>Subscribe</h3>
<p>Thanks for taking the time to read this post!  JavaScript development is one of the main topics of this blog, so if you enjoyed the post, please consider subscribing by using the <a href=\"http://feedpress.me/benmccormick\">feed</a>, <a href=\"http://twitter.com/benmccormickorg\">Twitter</a> or my <a href=\"http://eepurl.com/WFYon\">mailing list</a>. You also might want to check out the first post in this series on <a href=\"http://benmccormick.org/2015/11/30/es6-patterns-clean-higher-order-functions/\">cleaner higher order functions</a>.</p>
<div class=\"footnotes\">
<ol>
    <li class=\"footnote\" id=\"fn:1\">
        <p>
        And even a full implementation of fetch using XMLHttpRequest is only<a href=\"https://github.com/github/fetch/blob/master/fetch.js\"> ~300 lines</a>
        </p>
        <a href=\"#fnref:1\" title=\"return to article\"> ↩</a></p>
    </li>
</ol>
</div>
",
                  "author": {
                    "@type": "Person",
                    "name": "Ben McCormick"
                    "email": "mailto:ben@benmccormick.org",
                    "image": "/profile_pic.jpg",
                    "jobTitle": "Software Engineer",
                    "alumniOf": "Duke",
                    "birthPlace": "Pittsburgh, PA",
                    "gender": "male",
                    "url": "http://benmccormick.org",
              	    "sameAs" : [
                      "https://www.linkedin.com/in/benmccormick",
                      "http://twitter.com/ben336",
                    ]
                 }
              }</script><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font-size:112.5%;line-height:1.666em;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:georgia,serif;font-weight:normal;word-wrap:break-word;}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.5rem;line-height:2.499rem;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.27542rem;line-height:1.666rem;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.17608rem;line-height:1.666rem;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.666rem;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.92211rem;line-height:1.666rem;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;color:hsla(0,0%,0%,0.8);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.88547rem;line-height:1.666rem;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}ul{margin-left:1.666rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.666rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;font-size:0.85rem;line-height:1.666rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;font-size:1rem;line-height:1.666rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}blockquote{margin-left:1.666rem;margin-right:1.666rem;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.666rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.666rem;}b{font-weight:bold;}strong{font-weight:bold;}dt{font-weight:bold;}th{font-weight:bold;}li{margin-bottom:calc(1.666rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.666rem;margin-bottom:calc(1.666rem / 2);margin-top:calc(1.666rem / 2);}li > ul{margin-left:1.666rem;margin-bottom:calc(1.666rem / 2);margin-top:calc(1.666rem / 2);}code{font-size:0.85rem;line-height:1.666rem;}kbd{font-size:0.85rem;line-height:1.666rem;}samp{font-size:0.85rem;line-height:1.666rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:tnum;padding-left:1.11067rem;padding-right:1.11067rem;padding-top:0.833rem;padding-bottom:calc(0.833rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}</style><style>.header-link{color:hsla(0,0%,39%,.7)}.header-link:hover{color:#e2777a}#carbonads{height:100px;font-size:14px;width:300px;position:relative;background:#f0f0f0}.carbon-wrap{height:100px;display:-ms-flexbox;display:flex}.carbon-text{padding:5px 10px;max-height:80px;display:inline-block;overflow:hidden;line-height:1.3}.carbon-poweredby{color:hsla(0,0%,39%,.7);position:absolute;right:5px;bottom:0}@media all and (max-width:600px){#carbonads,.no-mobile{display:none}}@media all and (max-width:321px){html{font-size:100%!important}}.subscribe-button{color:#fff;background:#57a3e8;border-radius:4px;border:0;padding:5px 10px;margin:20px 0;cursor:pointer}.footnote p{display:inline-block;margin-bottom:0}.markdown pre{display:block;background:#fdf6e3;color:#657b83;overflow-y:hidden;padding:.2rem .5rem}.markdown pre code{background:none;border:none;border-radius:3px;display:inline-block;overflow:inherit;padding:0;white-space:inherit;word-wrap:normal;font-size:.7rem;line-height:1rem}code{border-radius:3px;white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;border:1px solid #ccc;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:0 .1625rem}.hljs,code{background:#fdf6e3;color:#657b83}.hljs{display:block;overflow-x:auto;padding:.5em}.hljs-comment,.hljs-quote{color:#93a1a1}.hljs-addition,.hljs-keyword,.hljs-selector-tag{color:#859900}.hljs-doctag,.hljs-literal,.hljs-meta .hljs-meta-string,.hljs-number,.hljs-regexp,.hljs-string{color:#2aa198}.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-title{color:#268bd2}.hljs-attr,.hljs-attribute,.hljs-class .hljs-title,.hljs-template-variable,.hljs-type,.hljs-variable{color:#b58900}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-meta .hljs-keyword,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-subst,.hljs-symbol{color:#cb4b16}.hljs-built_in,.hljs-deletion{color:#dc322f}.hljs-formula{background:#eee8d5}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}html{font-size:120%}body,h1,h2,h3,h4,h5,h6,p{font-family:brandon-grotesque,Brandon Grotesque,Helvetica Neue,Helvetica,Arial,Lucida Sans,Geneva,Verdana,sans-serif;text-rendering:optimizeLegibility}a{color:#e2777a;text-decoration:none}blockquote{border-left:5px solid #57a3e8;font-style:italic;background:#eee;font-weight:400;font-size:.9rem;padding:10px 20px;margin:0 0 30px -25px}blockquote p{margin-bottom:.667em}h2,h3{color:#57a3e8}.explanation{padding:10px;background:#eee;border-radius:10px;margin:20px auto;font-size:.85em}.article-body .reading-img img{width:150px;float:right;margin:0 10px 20px}.article-body img{max-height:200px;display:block;margin:40px auto 20px}.article-body img.full-width{max-height:none}.article-body img.half-width{max-height:none;width:50%}.bordered-img{border:3px solid #57a3e8}.mc-field-group{width:400px;display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;-ms-flex-pack:start;justify-content:flex-start;-ms-flex-align:center;align-items:center;padding:8px 0}.mc-field-group input{border-radius:3px;max-width:350px;width:80vw;border:1px solid #ccc;margin-right:10px;height:30px}.mc-field-group label{font-size:.9em;font-weight:600}#mc-embedded-subscribe{color:#fff;background:#57a3e8;border-radius:4px;border:0;padding:0 10px;margin:10px 0;cursor:pointer;width:40vw}#mc-embedded-subscribe:hover{background:#3e8acf}.twitter-row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.twitter-row>div{padding-right:20px;min-width:300px}.category-icon-wrapper{color:rgba(87,163,232,.5)}.category-icon{display:inline-block;width:.75em;margin-right:.5em}.category-icon *{fill:#57a3e8;fill:rgba(87,163,232,.5)}.category-icon>i{height:30px}</style></head><body class="landing-page" style="background:#FCFCFC;padding:0 10px;"><div id="react-mount"><div style="max-width:39.984rem;margin-left:auto;margin-right:auto;padding:2.499rem 1.2495rem;" data-reactroot="" data-reactid="1" data-react-checksum="114677298"><div style="display:flex;padding-bottom:0.5rem;margin-bottom:0.5rem;" data-reactid="2"><div style="flex-grow:3;display:flex;flex-direction:column;justify-content:space-around;" data-reactid="3"><h3 style="margin:0;padding-bottom:0;" data-reactid="4"><a style="box-shadow:none;text-decoration:none;color:inherit;" href="/" data-reactid="5">benmccormick.org</a></h3><div style="color:rgba(100,100,100, 0.7);" data-reactid="6"><a class="header-link" href="/subscribe/" data-reactid="7">Subscribe</a><span style="padding:0 0.33rem;" data-reactid="8">•</span><a class="header-link" href="/archive/" data-reactid="9">Archive</a><span style="padding:0 0.33rem;" data-reactid="10">•</span><a class="header-link" href="http://twitter.com/ben336" data-reactid="11">Twitter</a><span style="padding:0 0.33rem;" data-reactid="12">•</span><a class="header-link" href="/about/" data-reactid="13">About</a></div></div><div style="flex-shrink:2;" data-reactid="14"><span data-reactid="15"></span></div></div><div class="markdown" data-reactid="16"><!-- react-empty: 17 --><h5 style="display:block;color:rgba(100,100,100, 0.7);margin-bottom:0.4165rem;" data-reactid="18">December 29, 2015</h5><h1 style="margin-top:0;margin-bottom:1rem;" data-reactid="19">ES6 Patterns: Converting Callbacks to Promises</h1><div class="article-body" data-reactid="20"><div class="explanation">
I've been writing code using the new features defined in the ECMAScript 2015 version of JavaScript (<a href="http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/">more commonly known as ES6</a>) since January.  Throughout the year I've seen myself start using a few new patterns that I think make my code better.  I'm going to share them here with a few quick hitter articles.  If you missed it, I wrote about <a href="http://benmccormick.org/2015/11/30/es6-patterns-clean-higher-order-functions/">clean higher order functions</a> earlier this week.  This post focuses on working with asynchronous code in ES6.  
</div>
<h3>Background</h3>
<p>One of the nicest new features of ES6 JavaScript is the standardization of Promises.  Promises are a method for managing asynchronous code that serve as an alternative to the standard callback function syntax that has been the JavaScript standard for years.  If you’re unfamiliar with them, a good example of a Promise based API is the new <code>fetch</code> api provided by browsers.  <code>fetch</code> is a replacement for the older callback based XMLHttpRequest API.  A quick example of an HTTP request with the 2 APIs provides a nice comparison of how Promises can lead to clearer code.</p>
<p>A simple get request with XMLHttpRequest looks like this:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reqListener</span>(<span class="hljs-params"></span>) </span>{  
  <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">this</span>.responseText);  
  <span class="hljs-built_in">console</span>.log(data);  
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reqError</span>(<span class="hljs-params">err</span>) </span>{  
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fetch Error :-S'</span>, err);  
}

<span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();  
request.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">this</span>.responseText);  
  <span class="hljs-comment">//do stuff with data</span>
};  

request.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">'There was a problem with the request'</span>);
}
request.open(<span class="hljs-string">'get'</span>, <span class="hljs-string">'/api/foo/bar'</span>, <span class="hljs-literal">true</span>);  
request.send();
</code></pre>
<p>whereas with fetch we get this instead</p>
<pre><code>fetch(<span class="hljs-string">'/api/foo/bar'</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">return</span> data.json();
}).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(jsonData)</span> {</span>
    <span class="hljs-comment">//do stuff with the data</span>
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>
    alert(<span class="hljs-string">'There was a problem with the request'</span>);
})
</code></pre>
<p>This is admittedly a slightly unfair example due to XMLHttpRequest’s clunky object oriented API, but the key take away here is that promises allow for easier visualization of a program’s flow, as well as the ability to easily chain both synchronous and asynchronous operations together into a unified API.</p>
<p>Promises have been around for a little while in user-land.  There are a bunch of Promise libraries out there that eventually standardized on a spec called <code>Promises/A+</code>.  Promises/A+ compliant libraries include <a href="https://github.com/kriskowal/q">Q</a>, <a href="https://github.com/petkaantonov/bluebird">Bluebird</a>, and <a href="https://github.com/tildeio/rsvp.js">rsvp</a>.  There are also many older libraries that provide Promise-like capabilities but are not completely spec compatible, most notably <a href="https://api.jquery.com/category/deferred-object/">jQuery deferreds</a>.  But with ES6 Promises are being standardized.  Happily, since the implementation uses the standard that user-land libaries have agreed upon, the Promise spec is compatible with existing implementations, and existing code bases can remove their existing libraries in favor of the browser supplied version, or have code written to use the browser version interop cleanly with their existing code.  Support for Promises now exists in the latest versions of all major browsers, but it never made it to Internet Explorer and is Edge only for Microsoft browsers.  So most developers will still want to consider using a polyfill for the time being.</p>
<h3>Converting callback-driven code to use Promises</h3>
<p>If you believe that Promises are worthwhile, you’ll immediately encounter a problem in today’s JavaScript world.  Many JavaScript APIs, including most standard browser APIs and older but still popular libraries like jQuery and Backbone are heavily callback driven.  Rather than mixing 2 different styles of asynchronous code, wouldn’t it be nice if we could easily convert callback-based APIs to use Promises?  It turns out that it’s not that hard.  Let’s take the simplest example possible to start.  <code>setTimeout</code> is a straightforward browser API that waits for a specified period of time and then executes a callback.  A standard use looks like this:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doStuff</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">/*...*/</span>}

setTimeout(doStuff, <span class="hljs-number">300</span>);
</code></pre>
<p>A Promise-based API for this function would likely look something like this code.</p>
<pre><code><span class="hljs-function"><span class="hljs-title">timeout</span><span class="hljs-params">(<span class="hljs-number">300</span>)</span></span>.then(doStuff)
</code></pre>
<p>We can create an API like that using setTimeout.  To do that, we’ll need a function <code>timeout</code> which takes a timeout variable and returns a Promise.</p>
<p>You can define A+ compliant Promises using the Promise constructor, which expects a single function as an argument.  That function takes 2 arguments, a <code>resolve</code> function and a <code>reject</code> function.  The wonderful thing is that under the covers these are just callback functions that the Promise api glosses over.</p>
<p>Since we already have an API that can handle callbacks, the implementation of our <code>timeout</code> function is pretty simple.</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">delay</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
        setTimeout(resolve, delay);
    });
}
</code></pre>
<p>We don’t use the reject callback, since setTimeout doesn’t provide any hooks for an error state. So we pass resolve as the callback to setTimeout, and that is all we need.  Now we have a great chainable setTimeout function that we could include in a Promise chain.</p>
<p>Moving on to a more complicated example, let’s take our <code>XMLHttpRequest</code> code from above and see if we can create a simplified version of the <code>fetch</code> API using <code>XMLHttpRequest</code> under the covers.  In this case I’m going to use ES6 style arrow functions to reduce the boilerplate a bit.</p>
<pre><code><span class="hljs-keyword">const</span> fetch = <span class="hljs-function">(<span class="hljs-params">url, options = {method:<span class="hljs-string">'get'</span>}</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();  
    request.onload = resolve
    request.onerror = reject;
    request.open(options.method, url, <span class="hljs-literal">true</span>);  
    request.send();
});
</code></pre>
<p>This is a simplified implementation that doesn’t come close to covering all the use cases of fetch, but it provides a great example of how simple it can be to transform a callback based api to a Promise based one, without having to rewrite the existing code<sup id="fnref:1"><a href="#fn:1">1</a></sup>.</p>
<p>For what it’s worth, it is equally easy to convert functions in the other direction.  For instance a callback based implementation of fetch can be a one liner.</p>
<pre><code>const callbackFetch = <span class="hljs-function"><span class="hljs-params">(url, options, succ, err)</span> =&gt;</span> fetch(url, options).<span class="hljs-keyword">then</span>(succ).<span class="hljs-keyword">catch</span>(err);
</code></pre>
<p>It’s useful to know that the various syntaxes for asynchronous code in JavaScript are effectively equivalent and interoperable.  When designing APIs for your code, both for public libraries with external libraries and components that you use in an application, these patterns can be useful for providing a consistent API, even if you’re using code under the covers that presents it’s asynchronous code in a different way than your API.</p>
<h3>More Resources</h3>
<ul>
<li>The free online version of Exploring ES6 by Axel Rauschmayer has a <a href="http://exploringjs.com/es6/ch_promises.html">great chapter</a> on ES6 Promises explaining the API and how they fit in with the A+ standard.</li>
<li>There was also a <a href="http://blogs.msdn.com/b/eternalcoding/archive/2015/09/30/javascript-goes-to-asynchronous-city.aspx">great post by David Catuhe on one of the MSDN blogs</a> earlier this year highlighting how asynchronous code has evolved in JavaScript over the years, including a look at the new <code>async/await</code> patterns proposed for ES2016.</li>
</ul>
<h3>Subscribe</h3>
<p>Thanks for taking the time to read this post!  JavaScript development is one of the main topics of this blog, so if you enjoyed the post, please consider subscribing by using the <a href="http://feedpress.me/benmccormick">feed</a>, <a href="http://twitter.com/benmccormickorg">Twitter</a> or my <a href="http://eepurl.com/WFYon">mailing list</a>. You also might want to check out the first post in this series on <a href="http://benmccormick.org/2015/11/30/es6-patterns-clean-higher-order-functions/">cleaner higher order functions</a>.</p>
<div class="footnotes">
<ol>
    <li class="footnote" id="fn:1">
        <p>
        And even a full implementation of fetch using XMLHttpRequest is only<a href="https://github.com/github/fetch/blob/master/fetch.js"> ~300 lines</a>
        </p>
        <a href="#fnref:1" title="return to article"> ↩</a></p>
    </li>
</ol>
</div>
</div><hr style="margin-bottom:3.332rem;" data-reactid="21"/><noscript data-reactid="22"></noscript><div style="margin-bottom:4.165rem;" data-reactid="23"><a name="subscribe" class="subscribe-button" href="/subscribe/" data-reactid="24">Subscribe </a></div><div title="ES6 Patterns: Converting Callbacks to Promises" data-reactid="25"><div id="disqus_thread" data-reactid="26"></div><noscript data-reactid="27"><span data-reactid="28"><!-- react-text: 29 -->Please enable JavaScript to view the<!-- /react-text --><a href="http://disqus.com/?ref_noscript" data-reactid="30">comments powered by Disqus.</a></span></noscript><a href="http://disqus.com" class="dsq-brlink" data-reactid="31"><!-- react-text: 32 -->Blog comments powered by <!-- /react-text --><span class="logo-disqus" data-reactid="33">Disqus</span><!-- react-text: 34 -->.<!-- /react-text --></a></div></div><span style="display:block;clear:both;" data-reactid="35"> </span></div></div><script src="/bundle.js?t=1487533086580"></script><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-37323973-1', 'auto');
            ga('send', 'pageview');
        </script><script type="text/javascript">
              // adapted from: https://css-tricks.com/serviceworker-for-offline/
              // ServiceWorker is a progressive technology. Ignore unsupported browsers
              if ('serviceWorker' in navigator) {
              console.log('CLIENT: service worker registration in progress.');
              navigator.serviceWorker.register('/sw.js').then(function() {
                console.log('CLIENT: service worker registration complete.');
              }, function() {
                console.log('CLIENT: service worker registration failure.');
              });
              } else {
              console.log('CLIENT: service worker is not supported.');
              }
            </script></body></html>